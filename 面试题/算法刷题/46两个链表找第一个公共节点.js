// 使用暴力法

// 这个很简单,在第一个链表headA上遍历每个节点,每遍历到一个节点时,就对headB整个遍历一遍,直到出现相同的节点为止.
// 时间复杂度O(m*n),空间复杂度为O(1)

// 使用双栈法

// 这个方法的思路是,我们需要两个栈来保存两个链表,由于栈的特性,保存完之后,栈顶元素是链表的最后一个元素.
// 我们知道如果存在重复的节点,那么这两个栈中的上面几个元素是相同的
// 同时从两个栈顶弹出元素,直到弹出的两个元素不相等时,那么前一个元素就是我们要找的重复节点
// 时间复杂度O(m+n),空间复杂度O(m+n),用空间换取时间



//双指针
var getIntersectionNode = function (headA, headB) {
    var p1 = headA
    var p2 = headB
    while (p1 !== p2) {
        p1 = p1===null?headB:p1.next
        p2 = p2===null?headA:p2.next
    }
    return p1
};